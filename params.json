{"name":"CFSSL","tagline":"CFSSL: CloudFlare's PKI toolkit","body":"# CFSSL\r\n[![GoDoc](https://godoc.org/github.com/cloudflare/cfssl?status.png)](https://godoc.org/github.com/cloudflare/cfssl)\r\n## CloudFlare's SSL tool\r\n\r\nCFSSL is CloudFlare's SSL swiss army knife. It is both a command line\r\ntool and an HTTP API server for signing, verifying, and bundling SSL\r\ncertificates. It requires Go 1.4 to build.\r\n\r\n### Installation\r\n\r\nInstallation requires a [working Go\r\ninstallation](http://golang.org/doc/install) and a properly set `GOPATH`.\r\n\r\n```\r\n$ go get -u github.com/cloudflare/cfssl/cmd/cfssl\r\n```\r\n\r\nwill download and build the CFSSL tool, installing it in\r\n`$GOPATH/bin/cfssl`. To install the other utility programs that are in\r\nthis repo:\r\n\r\n```\r\n$ go get -u github.com/cloudflare/cfssl/cmd/...\r\n```\r\n\r\nThis will download, build, and install `cfssl`, `cfssljson`, and\r\n`mkbundle` into `$GOPATH/bin/`.\r\n\r\n\r\n### Using the Command Line Tool\r\n\r\nThe command line tool takes a command to specify what operation it\r\nshould carry out:\r\n\r\n       sign             signs a certificate\r\n       bundle           build a certificate bundle\r\n       genkey           generate a private key and a certificate request\r\n       gencert          generate a private key and a certificate\r\n       serve            start the API server\r\n       version          prints out the current version\r\n       selfsign         generates a self-signed certificate\r\n\r\nUse \"cfssl [command] -help\" to find out more about a command.\r\nThe version command takes no arguments.\r\n\r\n#### Signing\r\n\r\n```\r\ncfssl sign [-ca cert] [-ca-key key] hostname csr [subject]\r\n```\r\n\r\nThe hostname and csr are the client's host name and certificate\r\nrequest. The `-ca` and `-ca-key` flags are the CA's certificate\r\nand private key, respectively. By default, they are \"ca.pem\" and\r\n\"ca_key.pem\".  For example, assuming the CA's private key is in\r\n`/etc/ssl/private/cfssl_key.pem` and the CA's certificate is in\r\n`/etc/ssl/certs/cfssl.pem`, to sign the `cloudflare.pem` certificate\r\nfor cloudflare.com:\r\n\r\n```\r\ncfssl sign -ca /etc/ssl/certs/cfssl.pem \\\r\n           -ca-key /etc/ssl/private/cfssl_key.pem \\\r\n           cloudflare.com ./cloudflare.pem\r\n```\r\n\r\nIt is also possible to specify hostname and clientcert through '-hostname'\r\nand '-cert' flags. By doing so, flag values take precedence and will\r\noverwrite the arguments.\r\n\r\nThe subject is an optional file that contains subject information that\r\nshould be used in place of the information from the CSR. It should be\r\na JSON file with the type:\r\n\r\n```\r\n{\r\n    \"hosts\": [\r\n        \"example.com\",\r\n        \"www.example.com\"\r\n    ],\r\n    \"CN\": \"example.com\",\r\n    \"names\": [\r\n        {\r\n            \"C\": \"US\",\r\n            \"L\": \"San Francisco\",\r\n            \"O\": \"Internet Widgets, Inc.\",\r\n            \"OU\": \"WWW\",\r\n            \"ST\": \"California\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n#### Bundling\r\n\r\n```\r\ncfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \\\r\n             [-metadata metadata_file] [-flavor bundle_flavor] \\\r\n             -cert certificate_file [-key key_file]\r\n```\r\n\r\nThe bundles are used for the root and intermediate certificate\r\npools. In addition, platform metadata is specified through '-metadata'\r\nThe bundle files, metadata file (and auxiliary files) can be\r\nfound at [cfssl_trust](https://github.com/cloudflare/cfssl_trust)\r\n\r\n\r\nSpecify PEM-encoded client certificate and key through '-cert' and\r\n'-key' respectively. If key is specified, the bundle will be built\r\nand verified with the key. Otherwise the bundle will be built\r\nwithout a private key. Instead of file path, use '-' for reading\r\ncertificate PEM from stdin. It is also acceptable the certificate\r\nfile contains a (partial) certificate bundle.\r\n\r\nSpecify bundling flavor through '-flavor'. There are three flavors:\r\n'optimal' to generate a bundle of shortest chain and most advanced\r\ncryptographic algorithms, 'ubiquitous' to generate a bundle of most\r\nwidely acceptance across different browsers and OS platforms, and\r\n'force' to find an acceptable bundle which is identical to the\r\ncontent of the input certificate file.\r\n\r\nAlternatively, the client certificate can be pulled directly from\r\na domain. It is also possible to connect to the remote address\r\nthrough '-ip'.\r\n\r\n```\r\ncfssl bundle [-ca-bundle bundle] [-int-bundle bundle] \\\r\n             [-metadata metadata_file] [-flavor bundle_flavor] \\\r\n             -domain domain_name [-ip ip_address]\r\n```\r\n\r\nThe bundle output form should follow the example\r\n\r\n```\r\n{\r\n    \"bundle\": \"CERT_BUNDLE_IN_PEM\",\r\n    \"crt\": \"LEAF_CERT_IN_PEM\",\r\n    \"crl_support\": true,\r\n    \"expires\": \"2015-12-31T23:59:59Z\",\r\n    \"hostnames\": [\"example.com\"],\r\n    \"issuer\": \"ISSUER CERT SUBJECT\",\r\n    \"key\": \"KEY_IN_PEM\",\r\n    \"key_size\": 2048,\r\n    \"key_type\": \"2048-bit RSA\",\r\n    \"ocsp\": [\"http://ocsp.example-ca.com\"],\r\n    \"ocsp_support\": true,\r\n    \"root\": \"ROOT_CA_CERT_IN_PEM\",\r\n    \"signature\": \"SHA1WithRSA\",\r\n    \"subject\": \"LEAF CERT SUBJECT\",\r\n    \"status\": {\r\n        \"rebundled\": false,\r\n        \"expiring_SKIs\": [],\r\n        \"untrusted_root_stores\": [],\r\n        \"messages\": [],\r\n        \"code\": 0\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### Generating certificate signing request and private key\r\n\r\n```\r\ncfssl genkey csrjson\r\n```\r\n\r\nTo generate a private key and corresponding certificate request, specify\r\nthe key request as a JSON file. This file should follow the form\r\n\r\n```\r\n{\r\n    \"hosts\": [\r\n        \"example.com\",\r\n        \"www.example.com\"\r\n    ],\r\n    \"key\": {\r\n        \"algo\": \"rsa\",\r\n        \"size\": 2048\r\n    },\r\n    \"names\": [\r\n        {\r\n            \"C\": \"US\",\r\n            \"L\": \"San Francisco\",\r\n            \"O\": \"Internet Widgets, Inc.\",\r\n            \"OU\": \"WWW\",\r\n            \"ST\": \"California\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n#### Generating self-signed root CA certificate and private key\r\n\r\n```\r\ncfssl genkey -initca csrjson | cfssljson -bare ca\r\n```\r\n\r\nTo generate a self-signed root CA certificate, specify the key request as\r\nthe JSON file in the same format as in 'genkey'. Three PEM-encoded entities\r\nwill appear in the output: the private key, the csr, and the self-signed\r\ncertificate.\r\n\r\n#### Generating a remote-issued certificate and private key.\r\n\r\n```\r\ncfssl gencert -remote=remote_server hostname csrjson\r\n```\r\n\r\nThis is calls genkey, but has a remote CFSSL server sign and issue\r\na certificate.\r\n\r\n#### Generating a local-issued certificate and private key.\r\n\r\n```\r\ncfssl gencert -ca cert -ca-key key hostname csrjson\r\n```\r\n\r\nThis is generates and issues a certificate and private key from a local CA\r\nvia a JSON request.\r\n\r\n### Starting the API Server\r\n\r\nCFSSL comes with an HTTP-based API server; the endpoints are\r\ndocumented in `doc/api.txt`. The server is started with the \"serve\"\r\ncommand:\r\n\r\n```\r\ncfssl serve [-address address] [-ca cert] [-ca-bundle bundle] \\\r\n            [-ca-key key] [-int-bundle bundle] [-port port]   \\\r\n            [-remote remote_server]\r\n```\r\n\r\nAddress and port default to \"127.0.0.1:8888\". The `-ca` and `-ca-key`\r\narguments should be the PEM-encoded certificate and private key to use\r\nfor signing; by default, they are \"ca.pem\" and \"ca_key.pem\". The\r\n`-ca-bundle` and `-int-bundle` should be the certificate bundles used\r\nfor the root and intermediate certificate pools, respectively. These\r\ndefault to \"ca-bundle.crt\" and \"int-bundle.\" If the \"remote\" option is\r\nprovided, all signature operations will be forwarded to the remote CFSSL.\r\n\r\nThe amount of logging can be controlled with the `-loglevel` option. This\r\ncomes *before* the serve command:\r\n\r\n```\r\ncfssl -loglevel 2 serve\r\n```\r\n\r\nThe levels are:\r\n\r\n* 0. DEBUG\r\n* 1. INFO (this is the default level)\r\n* 2. WARNING\r\n* 3. ERROR\r\n* 4. CRITICAL\r\n\r\n\r\n### The mkbundle Utility\r\n\r\n`mkbundle` is used to build the root and intermediate bundles used in\r\nverifying certificates. It can be installed with\r\n\r\n```\r\ngo get -u github.com/cloudflare/cfssl/cmd/mkbundle\r\n```\r\n\r\nIt takes a collection of certificates, checks for CRL revocation (OCSP\r\nsupport is planned for the next release) and expired certificates, and\r\nbundles them into one file. It takes directories of certificates and\r\ncertificate files (which may contain multiple certificates). For example,\r\nif the directory `intermediates` contains a number of intermediate\r\ncertificates,\r\n\r\n```\r\nmkbundle -f int-bundle.crt intermediates\r\n```\r\n\r\nwill check those certificates and combine valid ones into a single\r\n`int-bundle.crt` file.\r\n\r\nThe `-f` flag specifies an output name; `-loglevel` specifies the verbosity\r\nof the logging (using the same loglevels above), and `-nw` controls the\r\nnumber of revocation-checking workers.\r\n\r\n### The cfssljson Utility\r\n\r\nMost of the output from `cfssl` is in JSON. The `cfssljson` will take\r\nthis output and split it out into separate key, certificate, CSR, and\r\nbundle files as appropriate. The tool takes a single flag, `-f`, that\r\nspecifies the input file, and an argument that specifies the base name for\r\nthe files produced. If the input filename is \"-\" (which is the default),\r\n`cfssljson` reads from standard input. It maps keys in the JSON file to\r\nfilenames in the following way:\r\n\r\n* if there is a \"cert\" (or if not, if there's a \"certificate\") field, the\r\n  file \"basename.pem\" will be produced.\r\n* if there is a \"key\" (or if not, if there's a \"private_key\") field, the\r\n  file \"basename-key.pem\" will be produced.\r\n* if there is a \"csr\" (or if not, if there's a \"certificate_request\") field,\r\n  the file \"basename.csr\" will be produced.\r\n* if there is a \"bundle\" field, the file \"basename-bundle.pem\" will\r\n  be producd.\r\n\r\n### Additional Documentation\r\n\r\nAdditional documentation can be found in the \"doc/\" directory:\r\n\r\n* `api.txt`: documents the API endpoints\r\n* `bootstrap.txt`: a walkthrough from building the package to getting\r\n  up and running\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}